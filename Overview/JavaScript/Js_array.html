<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    


    <script>

        // listeler ile ayni denebilir 

        // , ile ayrilan hersey array in bir elemani 

        // peardeck geldi email 

        // array icinde baska bir array veya bir object saklanabilir

        var cars = ["Opel", "Audi", "Bmw"];

        console.log(cars);


        // object oldugu icin kendi icin methodlari var lenth var console da 

        // var cars2 = Array.of("Opel", "Audi", "Bmw");

        // console.log(cars2);



                //  burada tek string oldugu icin tek elemanli array
        let number = Array.of("1, 2, 3");

        console.log(number);



                //  3 elemanli

            number2 = Array.of("1", "2", "3");
            console.log(number2);


                //  3 elemanli veri tipleri number:

            number3 = Array.of(1, 2, 3);
            console.log(number3);






                /// Array.from  method:

            let variable = "123";
            number4 = Array.from(variable);
            console.log(number4);

                /// join:
            let myJoin = number4.join();
            console.log(typeof(myJoin),myJoin);

            let myJoin2 = number4.join(" & ");
            console.log(myJoin2);












            ///  3. method: new array


        var cars3 = new Array("Opel", "Audi", "Bmw");

        console.log(cars3);



        var num1 = new Array(2, 10);

        console.log(num1);

        var num2 = new Array(10);

        console.log(num2);

        // bu 10 tane bos eleman döndürdü
        /// bazen hata veriyor
        // ilk yöntem en cok kullanilan








        var cars4 = ["Opel", "Audi", "Bmw", [1, 2, true]];

        console.log(cars4[0]);
        console.log(cars4[3][2]);


            //  direkt assign:

        cars4[3] = "Mercedes";

        console.log(cars4);







        const cars5 = ["Opel", "Audi", "Bmw", [1, 2, true]];

        cars5[3] = "Mercedes";

        console.log(cars5);


        // burada constant elemanin heap bölgesinde bulunan kismina bir atama yaptik 


            cars5[2] = "toyota"; 
        
            console.log(cars5);


        // cars5 = [1, 2, 3];   buna izin vermez constant tanimlama yaptigi icin 
 
        // console.log(cars5); 


        // object lerde indexleme yok key value ile calisir 

        const myObject =  {"Bir" : 1, "Iki" : 2};
        console.log(myObject);

        console.log(myObject["Bir"]);
        console.log(myObject["Iki"]);


        // array in adresleri binary olarak hexe decimal adresler saklanir steak de

        // steak de adresler saklandigi icin adreste bir degisiklik 
        // yapmadigimiz sürece degisiklik yapabilirz

        cars5[4] = "porsche";

        console.log(cars5);

        // cars5[10] = "Ferrari";

        // console.log(cars5);

        ///  arada 5 tane bos eleman var diyor yani array 10 eleman oldu

        // console.log(cars5.length);




        // array uzunlugu bilmiyorsak en sona eleman atama


        // current array cars5 = ['Opel', 'Audi', 'toyota', 'Mercedes', 'porsche']

        cars5[cars5.length] = "Honda";
        console.log(cars5);

        //  burada length - 1 kullanmiyoruz cünkü en son 
        //  eleman indexlemeye dahil degildir





        // aralarda bulunan empty lerin tipi undefined

        //  empty kullanim mesela bir binada bos daireler icin 




        ////  array e empty eleman atama 2. yöntem:



        let cars6 = ["opel", , , , , "audi"];

        console.log(cars6);

        





        ///  arraylerin tipi object tir

        // console.log(typeof(cars));


            ////  instanceof bir veriyi parantez icerisine 
            // yazilan veri tipi ile karsilastirir. 
            ///   eger dogru ise true degilse false return

        console.log(cars instanceof Object);  
        console.log(cars instanceof Array);  
        console.log(cars instanceof String);  


        









        // array olup olmadigini anlama 2. method:

        console.log(Array.isArray(cars));

        



        // arraylere indexlerle erisiyoruz
        // objectlere keylerle erisiyoruz yani stringlerle elemanlari ile 



        // null da da tip olarak object görünür:
        ///  ancak instanceof da false verir 

        console.log(null instanceof Object);
        console.log(typeof(null));
        






        
// stack veya heap ten ziyade
// biz değişken tanımlarken ona bir adres veriyoruz.
// const ile tanımlayınca adresi değiştiremiyoruz. 
// dolayısıyla her iki alanda da değişiklik yapamıyoruz
// primitive olan her değişkene yeni değer atadığımızda 
// stack ta bir adres tanımlanıyor. değer oraya yazılıyor. 
// bizim değişkenin işaret ettiği adres yeni tahsis edilen oluyor.

// bir de fonksiyonlara değer aktarırken de aynı


// ama const olana atama yapmıyor kopya değişken veriliyor.
// deneyip görmek daha faydalı olacaktır

        






    // length
const fruits = ["Banana", "Orange", "Apple"];
fruits[6] = "Lemon";

console.log(fruits)
console.log(fruits.length)
 





        /// concat

    const fruits1 = ["Banana", "Orange","Lemon"];
    const vegetables = ['Broccoli','Celery','Parsley','Artichoke']

    console.log(fruits1.concat(vegetables));

    console.log(fruits1);

            // bir degiskene atasaydik yeni bir array olusturacakti
            //  ama orijinalinde degisiklik olmaz


    console.log(fruits1.concat("Fig", 3, "Pear"));

    // hicbiri orijini bozmaz 



            // string ve array toplaminda sonuc string:

    console.log("" + fruits1);

            // iki arrayi toplarsak o da string dönecek 

        newArray = fruits + fruits1;
        console.log(newArray, typeof(newArray));


    


        // 2 .  method

    console.log(fruits.toString());

    // console.log(fruits + vegetables);
    // console.log(fruits + "" + vegetables);

    // concat ve tostring methodlari ile array ler
    //  üzerinde birlestirme ve string e cevirme 
    // islemleri yapabiliriz







            ////  callback   

    // sort array icindeki rakamlari siralamaz
    // bunun icin bir method
    
    const daltones = ['Joe','Jack','William','Avarel'];

    console.log(daltones.sort());

    console.log(daltones.sort((a, b) => a-b));

        ///   burada sort a her seferinde a ve b al diyoruz.
        //  ve a - b return et diyoruz


    // const num = [40, 100, 1, 5, 25, 10];

    // console.log(num.sort());  // string olarak siralanir

    // console.log(num.sort((a, b) => a - b));

    // python tutor a kod yaz görsellestirir 


    // her seferinde 2 sayi aliyor soldakinden sagdakini cikariyor
    // eger sonuc pozitif ise soldaki saga gitmesi gerekir diyor ve yer degistiriyor
    /// her bir yeni sayi aldiginda yine sola dogru dönüs yapiyor
    //  ve sola dogru giderken negatif sonuc bulana kadar
    //  devam ediyor
    // 29 adimda gerceklesir


    // İçerideki fonksiyonu anlamadıysanız sorun değil, zorlamayın kendinizi. 
    // Buna callback diyoruz. İleri derslerin konusu. 
    // Burada sadece rakamları nasıl sıralayacağız onu bilin yeter. 
    // Yöntem bu. Detaylara takılmayın şimdilik.



            // de büyükten küçüğe sıralıyor

    const daltones1 = ['Joe','Jack','William','Avarel'];

    console.log(daltones1.sort((b,a) => a-b)); 
     


            //  önemli olan burada a ve b lerin 
            //  yerini degistirmektir. iki türlü olabilir

    const num8 = [40, 100, 1, 5, 25, 10];

    // console.log(num8.sort((b, a) => a - b));
    console.log(num8.sort((a,b) => b-a));
    console.log(num8);   //  sort methodu orijinali bozar





    // Js de max ve min gibi built in func lar yoktur
    // Bunun icin öncelikle yukaridaki func i calistirip
    ///  daha sonra ilk veya son elemani seceriz

    // length - 1 en büyük rakami max rakami verir 
    // birinci elemanda min i verir 

    let minimum = num8[num8.length - 1];
    console.log(minimum);


    let maximum = num8[0];
    console.log(maximum);





        ///  2. method:

        // console.log(num.sort((a,b)=> a - b) [0]) en kücük eleman





    // push ile pop tam tersi 
    // pop un icine deger yazilamaz
    //  sondaki elemani siler






        //   reverse:


    const daltones2 = ['Joe','Jack','William','Avarel'];

    // console.log(daltones2.reverse());

        // bu da orijinali bozar
    daltones2.reverse()
    console.log(daltones2);

    //  reverse methodu orijinal array i bozar

    // concat orijinali degistirmez











    ////  push ve pop methodu:

    const fruits2 = ["Banana", "Orange", "Apple", "Mango"];

    // fruits2.push("Pears");

    // console.log(fruits2);

    //  birden cok eleman push etme

    fruits2.push("Pears", "pineapple", 2);

    console.log(fruits2);




            //  pop method:

    let pop1 = fruits2.pop();
    console.log(pop1);


    let pop2 = fruits2.pop();
    console.log(pop2);

    console.log(fruits.pop());

    // yukaridaki 2 yöntemde de pop methodu
    // sildigi elemani return eder
    

        //  ve sonuc olarak da orijinali degisir

    console.log(fruits2);



    // pop sildigi elemani yazdirir. bunu bir degiskene atayarak 
    // baska bir yerde kullanabilirz

    // https://www.w3schools.com/jsref/jsref_obj_array.asp




        
            /// shift en bastakini siler

    // bunun icine de deger girilemez

    console.log(fruits2);  //  current array

    let shift1 = fruits2.shift();

    console.log(fruits2);






            //  unshift de array in en basina eleman ekler ve 
    // bize bir rakam döndürür ekledikten sonra ki yeni array uzunlugu 


    console.log(fruits2);

        //  1. method:
        //  bu sekilde degiskene atamadan kullanimda
        // normal orijinal array e atama yapilir
        ///  ve yeni array return edilir

    fruits2.unshift("unshift1");
    console.log(fruits2);


        //  2. method: 
        //  bu kullanimda ise output sadece length in uzunlugu 

    let unshift2 = fruits2.unshift("unshift2");
    console.log(unshift2);


        /// 3. method:
        //  bu yöntemde de sadece rakam return edilir

    console.log(fruits2.unshift("unshift3"));




    



    const uns = fruits2.unshift("Pears", "fig", 2, [1, 2]);

    console.log(uns);  //  unshift bize sayi döndürür

    console.log(fruits2);


    ///  push u da degiskene atayarak dene ve bu degiskeni yazdir yine sayi döndürecek


    fruits2.push("push1");
    console.log(fruits2);


    let push2 = fruits2.push("push2");
    console.log(push2);   ///  13 sayisi döndürür
 

    // pop push unshift en basta ve sonda calisir
    // splice ise array icinde 













    /////////////  splice:

    ///  splice ekleme demektir
    //  splice methodu da normal degiskene atanmadan kullanilirsa
    //  array in en güncel halini print eder
    ///  degiskene atanirsa ise bu durumda sadece sildigi 
    ///  elemanlarin sayisini degil kendisini print eder


    var names = ["John", "Edward", "Victor"];

    var deleted = names.splice(1, 0, "Mark", "James");
    console.log(deleted);
    console.log(names);

    /// degiskene atasak da atamasak da orijinali degistirir

    // console.log(deleted);   // deleted yazdirirsak sildiklerini print eder
    // console.log(names);     //  bu ise array in son durumunu


    // names.splice(1, 0, "splice1", "splice2");
    // console.log(names);




        //  burada 2 tane silemez sonda eleman olmadigi icin
        // 1 tane siler 2 tane ekler
    // names.splice(2, 2, "Mark", "James");

    // console.log(names);








    // names.splice(2, 20, "Mark", "James");

    // console.log(names);


    // var deleted = names.splice(1, 1, "Mark", "James");
    // degiskene atadigi icin sildigi elemani gösterdi

    // console.log({deleted});

    // console.log(names);
    // console.log(names.splice(1, 1, "Mark", "James"));



    // 2. deger 0 olursa birsey silmez araya ekler

    // silinen birsey yoksa bos array döndürür














    /////////////  slice:

    ///  orijinali bozmaz 
    // ikinci deger dahil olmaz

    // tek rakam verdiysek sona kadar alir 

    const months = ['Jan', 'March', 'April', 'June',"july"];

    const springs = months.slice(1, 3);

    console.log(springs);

    console.log(months.slice(1, -2));

    console.log(months.slice(-4, -2));
    /// her zaman soldan saga calisir

    // console.log(months.slice(-4, -5));  //  bos string

    console.log(months.slice(-4, 3));

    console.log(months);  ////  orijinal degismez








    /// indexof lastindexof:

    // indexof ilk buldugu 

        // genel tekrar
    const colors = ["Red", "Yellow", "Green", "Blue", "Pink", "Green"];

    const colors2 = ["Red", "Yellow"];

    // colors.push("tarik");

    // colors.unshift("tarik");

    // colors.splice(3, 0, "tarik")

    // console.log(colors);

    
        //  concat methodu bu sekilde calismaz
        // ve bu nedenle de orijinali degismez
        // ancak yeni bir variable ataryarak 
        ///  iki array birlesiminden yeni bir
        //  array olusturma sansimiz var

    colors.concat(colors2);
    console.log(colors);



    console.log(colors.concat(colors2));










    // const colors = ["Red", "Yellow", "Green", "Blue", "Pink", "Green"];
    
    console.log(colors.indexOf("Green"));

    console.log(colors.indexOf("Green", 3));







    /// lastindex of:


        ///  eger aradigimiz eleman array de tek bir tane
        // ise, bu durumda normal indexof gibi hangi index de bulunuyorsa
        //  o index noyu print eder 

        // ama array de birden cok kez geciyorsa bu eleman 
        //   bu durumda arama islemi sondan basladigi icin 
        // ilk önce en sondaki elemanin index no print edilir


    console.log(colors.lastIndexOf("Red"));
    console.log(colors.lastIndexOf("Yellow"));
    console.log(colors.lastIndexOf("Green"));

    //  en sondaki green i atlamak ve bir sonraki
    //   green i print etmek icin burada 5 yazmammiz gerekir

    console.log(colors.lastIndexOf("Green", 4));


    </script>


</body>
</html>